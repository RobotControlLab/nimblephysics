#ifndef DART_BIOMECH_DYNAMICS_FITTER_HPP_
#define DART_BIOMECH_DYNAMICS_FITTER_HPP_

#include <memory>
#include <tuple>
#include <vector>

#include <coin/IpIpoptApplication.hpp>
#include <coin/IpTNLP.hpp>

#include "dart/biomechanics/ForcePlate.hpp"
#include "dart/biomechanics/MarkerFitter.hpp"
#include "dart/dynamics/BodyNode.hpp"
#include "dart/dynamics/Skeleton.hpp"
#include "dart/dynamics/SmartPointer.hpp"
#include "dart/math/Geometry.hpp"
#include "dart/math/MathTypes.hpp"
#include "dart/neural/DifferentiableExternalForce.hpp"
#include "dart/neural/WithRespectTo.hpp"

#define HUMAN_DENSITY_KG_M3 985.0

namespace dart {
namespace biomechanics {

/**
 * This class factors out the code to deal with calculating residual forces, and
 * the associated Jacobians of residual force with respect to lots of different
 * inputs.
 */
class ResidualForceHelper
{
public:
  ResidualForceHelper(
      std::shared_ptr<dynamics::Skeleton> skeleton,
      std::vector<int> forceBodies);

  ///////////////////////////////////////////
  // Computes the full inverse dynamics vector for a specific timestep
  Eigen::VectorXs calculateInverseDynamics(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the full inverse dynamics vector for a specific timestep
  Eigen::VectorXs calculateForwardDynamics(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs tau,
      Eigen::VectorXs forcesConcat);

  //////////////////////////////////////////
  // Computes the joint torques generated by the contact forces at this pose.
  Eigen::VectorXs calculateContactForceTaus(
      Eigen::VectorXs q, Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the residual for a specific timestep
  Eigen::Vector6s calculateResidual(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the residual norm for a specific timestep
  s_t calculateResidualNorm(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      s_t torquesMultiple,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the Jacobian of the residual with respect to `wrt`
  Eigen::MatrixXs calculateResidualJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ///////////////////////////////////////////
  // Computes the Jacobian of the residual with respect to `wrt`
  Eigen::MatrixXs finiteDifferenceResidualJacobianWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt);

  ///////////////////////////////////////////
  // Computes the gradient of the residual norm with respect to `wrt`
  Eigen::VectorXs calculateResidualNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      s_t torquesMultiple,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of the residual norm with respect to `wrt`
  Eigen::VectorXs finiteDifferenceResidualNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      s_t torquesMultiple,
      bool useL1);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s calculateRootAngularResidualJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s finiteDifferenceRootAngularResidualJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s calculateRootAngularResidualJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s finiteDifferenceRootAngularResidualJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s calculateRootAngularResidualJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix3s
  finiteDifferenceRootAngularResidualJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix6s calculateRootResidualJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // Computes the Jacobian relating changes in the root position to changes in
  // the residual torque
  Eigen::Matrix6s finiteDifferenceRootResidualJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the residual at the root, then transforms that to the COM and
  // expresses the torque as a spatial vector (even if the root joint uses euler
  // coordinates for rotation). Linear force is left unchanged.
  Eigen::Vector6s calculateCOMSpatialResidual(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the residual at the root, then transforms that to the COM and
  // expresses the torque as a spatial vector (even if the root joint uses euler
  // coordinates for rotation). Linear force is left unchanged.
  Eigen::Vector3s calculateCOMAngularResidual(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the acceleration we would need at the root in order to keep
  // everything else the same, and end up with zero residuals at the root.
  Eigen::Vector6s calculateResidualFreeRootAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the angular acceleration we would need at the root in order
  // to keep everything else the same, and end up with zero residuals at the
  // root.
  Eigen::Vector3s calculateResidualFreeAngularAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the linear acceleration we would need at the root in order
  // to keep everything else the same, and end up with zero residuals at the
  // root.
  Eigen::Vector3s calculateResidualFreeLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix3s
  calculateResidualFreeRootAngularAccelerationJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix3s
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtLinearPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix3s
  calculateResidualFreeRootAngularAccelerationJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix3s
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtLinearVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // acceleration.
  Eigen::Matrix3s
  calculateResidualFreeRootAngularAccelerationJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // acceleration.
  Eigen::Matrix3s
  finiteDifferenceResidualFreeRootAngularAccelerationJacobianWrtLinearAcceleration(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix6s calculateResidualFreeRootAccelerationJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // position.
  Eigen::Matrix6s
  finiteDifferenceResidualFreeRootAccelerationJacobianWrtPosition(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix6s calculateResidualFreeRootAccelerationJacobianWrtVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::Matrix6s
  finiteDifferenceResidualFreeRootAccelerationJacobianWrtVelocity(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs calculateResidualFreeRootAccelerationJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs
  finiteDifferenceResidualFreeRootAccelerationJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs calculateScratchJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the change in angular acceleration as we change the root
  // velocity.
  Eigen::VectorXs finiteDifferenceScratchJacobianWrtInvMass(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This computes the location that we would need to move the COM to in order
  // to center the angular residuals. Moving the COM to the computed location
  // doesn't remove angular residuals, but ensures that any remaining residuals
  // are parallel to the net external force on the body.
  Eigen::Vector3s calculateComToCenterAngularResiduals(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a legal root
  // trajectory. Here x is a 12 dimensional vector, composed of the
  // concatenation of the initial pos offset, and initial velocity offset.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs> getRootTrajectoryLinearSystem(
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool includeResidualAccs);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a legal root
  // trajectory. Here x is a 12 dimensional vector, composed of the
  // concatenation of the initial pos offset, and initial velocity offset.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs>
  finiteDifferenceRootTrajectoryLinearSystem(
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF,
      bool includeResidualAccs);

  ////////////////////////////////////////////
  // This will go through and compute the "residual-free root acceleration" at
  // each timestep, in that timestep's INPUT CONFIGURATION, and then integrate
  // all those accelerations together to create a new trajeoctory.
  //
  // IMPORTANT: This does NOT allow intermediate "new accelerations" to affect
  // subsequent timestep computations. ALL the "new accelerations" are computed
  // FIRST, and ONLY AFTER EVERY ACCELERATION IS ALREADY COMPUTED are they all
  // integrated together to get a new trajectory.
  //
  // THIS DOES NOT GUARANTEE PHYSICAL CONSISTENCY!!! It is here to help test the
  // getRootTrajectoryLinearSystem() method, and that's pretty much it.
  Eigen::VectorXs getRootTrajectoryLinearSystemTestOutput(
      Eigen::Vector6s initialPosOffset,
      Eigen::Vector6s initialVelOffset,
      Eigen::VectorXs residualAccelerations,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  Eigen::MatrixXs getRootTrajectoryLinearSystemPoses(
      Eigen::Vector6s initialPosOffset,
      Eigen::Vector6s initialVelOffset,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  Eigen::MatrixXs getResidualFreePoses(
      Eigen::Vector6s initialPosOffset,
      Eigen::Vector6s initialVelOffset,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  ////////////////////////////////////////////
  // This returns a matrix A and vector b, such that Ax+b gives you a trajectory
  // with zero linear residuals, along with a "hypothetical" angular trajectory.
  // The angular trajectory is "hypothetical" in that changing the angles of the
  // root at any timestep will break the linear residuals, so this is just the
  // integration of the "residual free angular acceleration" computed at each
  // timestep. Happily, this hypothetical angular trajectory is linear in the
  // initial conditions, so it's possible to solve this whole system in one
  // shot. This won't produce something legal, but it well let you get your
  // angular accelerations quite close to the desired trajectory.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs> getLinearTrajectoryLinearSystem(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  ////////////////////////////////////////////
  // This returns the same thing as getLinearTrajectoryLinearSystem(), in
  // theory.
  std::pair<Eigen::MatrixXs, Eigen::VectorXs>
  finiteDifferenceLinearTrajectoryLinearSystem(
      s_t dt,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

  ////////////////////////////////////////////
  // This produces the same output as you would get from using A*x+b from
  // getLinearTrajectoryLinearSystem().
  Eigen::VectorXs getLinearTrajectoryLinearSystemTestOutput(
      s_t dt,
      Eigen::Vector3s linPosOffset,
      Eigen::Vector3s linVelOffset,
      Eigen::VectorXs linResiduals,
      Eigen::Vector3s angPosOffset,
      Eigen::Vector3s angVelOffset,
      Eigen::VectorXs angResiduals,
      Eigen::MatrixXs qs,
      Eigen::MatrixXs dqs,
      Eigen::MatrixXs ddqs,
      Eigen::MatrixXs forces,
      std::vector<bool> probablyMissingGRF);

protected:
  std::shared_ptr<dynamics::Skeleton> mSkel;
  std::vector<neural::DifferentiableExternalForce> mForces;
};

/**
 * This class factors out the logistics for mapping spatial accelerations back
 * to ground reaction forces.
 */
class SpatialNewtonHelper
{
public:
  SpatialNewtonHelper(std::shared_ptr<dynamics::Skeleton> skeleton);

  ///////////////////////////////////////////
  // Computes the f=m*a (in linear components only) difference from observed
  // forces, and presents that in 3-axis form (X,Y,Z world coordinates) in
  // Newtons.
  Eigen::Vector3s calculateLinearForceGap(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat);

  ///////////////////////////////////////////
  // Computes the f=m*a (in linear components only) difference from observed
  // forces, and presents that in 3-axis form (X,Y,Z world coordinates) in
  // Newtons.
  s_t calculateLinearForceGapNorm(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of gap norm with respect to `wrt`
  Eigen::VectorXs calculateLinearForceGapNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of gap norm with respect to `wrt`
  Eigen::VectorXs finiteDifferenceLinearForceGapNormGradientWrt(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs forcesConcat,
      neural::WithRespectTo* wrt,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the norm of the spatial acceleration vector for each body
  s_t calculateAccelerationNorm(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs weightBodies,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of the norm of the spatial acceleration vector for
  // each body
  Eigen::VectorXs calculateAccelerationNormGradient(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs weightBodies,
      neural::WithRespectTo* wrt,
      bool useL1);

  ///////////////////////////////////////////
  // Computes the gradient of the norm of the spatial acceleration vector for
  // each body
  Eigen::VectorXs finiteDifferenceAccelerationNormGradient(
      Eigen::VectorXs q,
      Eigen::VectorXs dq,
      Eigen::VectorXs ddq,
      Eigen::VectorXs weightBodies,
      neural::WithRespectTo* wrt,
      bool useL1);

protected:
  std::shared_ptr<dynamics::Skeleton> mSkel;
};

/**
 * We create a single initialization object, and pass it around to optimization
 * problems to re-use, because it's not super cheap to construct.
 */
struct DynamicsInitialization
{
  ///////////////////////////////////////////
  // Inputs from files
  std::vector<std::vector<ForcePlate>> forcePlateTrials;
  std::vector<Eigen::MatrixXs> originalPoses;
  std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
      markerObservationTrials;
  std::vector<s_t> trialTimesteps;

  ///////////////////////////////////////////
  // Assigning GRFs to specific feet
  std::vector<Eigen::MatrixXs> grfTrials;
  std::vector<int> grfBodyIndices;
  std::vector<dynamics::BodyNode*> grfBodyNodes;

  ///////////////////////////////////////////
  // After the pipeline runs, these hold GRF forces that are perfectly
  // consistent with physics equations. These are the same format as `grfTrials`
  std::vector<Eigen::MatrixXs> perfectGrfTrials;
  std::vector<Eigen::MatrixXs> perfectTorques;
  std::vector<Eigen::MatrixXs> perfectGrfAsCopTorqueForces;
  // These are corrected copy of `forcePlateTrials`
  std::vector<std::vector<ForcePlate>> perfectForcePlateTrials;

  ///////////////////////////////////////////
  // Foot ground contact, and rendering
  std::vector<s_t> groundHeight;
  std::vector<bool> flatGround;
  std::vector<std::vector<dynamics::BodyNode*>> contactBodies;
  std::vector<std::vector<std::vector<s_t>>> grfBodyContactSphereRadius;
  std::vector<std::vector<std::vector<bool>>> grfBodyForceActive;
  std::vector<std::vector<std::vector<bool>>> grfBodySphereInContact;
  std::vector<std::vector<Eigen::Vector3s>> defaultForcePlateCorners;
  std::vector<std::vector<std::vector<bool>>> grfBodyOffForcePlate;
  // This is the critical value, telling us if we think we're receiving support
  // from off a force plate on this frame
  std::vector<std::vector<bool>> probablyMissingGRF;

  ///////////////////////////////////////////
  // Pure dynamics values
  Eigen::VectorXs bodyMasses;
  Eigen::VectorXs groupMasses;
  Eigen::Matrix<s_t, 3, Eigen::Dynamic> bodyCom;
  Eigen::Matrix<s_t, 6, Eigen::Dynamic> bodyInertia;
  Eigen::VectorXs groupInertias;

  ///////////////////////////////////////////
  // Values from the kinematics fitter that are relevant here as well. The key
  // difference is that the per-trial split is explicit here, because it's so
  // important for the dynamics and indexing.
  std::vector<Eigen::MatrixXs> poseTrials;
  Eigen::VectorXs groupScales;
  std::map<std::string, Eigen::Vector3s> markerOffsets;
  std::vector<std::string> trackingMarkers;

  std::vector<dynamics::Joint*> joints;
  std::vector<std::vector<std::string>> jointsAdjacentMarkers;
  Eigen::VectorXs jointWeights;
  std::vector<Eigen::MatrixXs> jointCenters;
  Eigen::VectorXs axisWeights;
  std::vector<Eigen::MatrixXs> jointAxis;

  ///////////////////////////////////////////
  // Convenience objects
  std::map<std::string, std::pair<dynamics::BodyNode*, Eigen::Vector3s>>
      updatedMarkerMap;

  ///////////////////////////////////////////
  // To support regularization
  Eigen::VectorXs originalGroupMasses;
  Eigen::VectorXs originalGroupCOMs;
  Eigen::VectorXs originalGroupInertias;
  Eigen::VectorXs originalGroupScales;
  std::map<std::string, Eigen::Vector3s> originalMarkerOffsets;
};

class DynamicsFitProblemConfig
{
public:
  DynamicsFitProblemConfig(std::shared_ptr<dynamics::Skeleton> skeleton);
  DynamicsFitProblemConfig& setDefaults(bool l1 = false);

  DynamicsFitProblemConfig& setIncludeMasses(bool value);
  DynamicsFitProblemConfig& setIncludeCOMs(bool value);
  DynamicsFitProblemConfig& setIncludeInertias(bool value);
  DynamicsFitProblemConfig& setIncludePoses(bool value);
  DynamicsFitProblemConfig& setIncludeMarkerOffsets(bool value);
  DynamicsFitProblemConfig& setIncludeBodyScales(bool value);

  DynamicsFitProblemConfig& setLinearNewtonWeight(s_t weight);
  DynamicsFitProblemConfig& setResidualWeight(s_t weight);
  DynamicsFitProblemConfig& setMarkerWeight(s_t weight);
  DynamicsFitProblemConfig& setJointWeight(s_t weight);

  DynamicsFitProblemConfig& setConstrainResidualsZero(bool constrain);
  DynamicsFitProblemConfig& setLinearNewtonUseL1(bool l1);
  DynamicsFitProblemConfig& setResidualUseL1(bool l1);
  DynamicsFitProblemConfig& setMarkerUseL1(bool l1);

  DynamicsFitProblemConfig& setRegularizeSpatialAcc(s_t value);
  DynamicsFitProblemConfig& setRegularizeSpatialAccBodyWeights(
      Eigen::VectorXs bodyWeights);
  DynamicsFitProblemConfig& setRegularizeSpatialAccUseL1(bool l1);

  DynamicsFitProblemConfig& setResidualTorqueMultiple(s_t value);
  DynamicsFitProblemConfig& setRegularizeMasses(s_t value);
  DynamicsFitProblemConfig& setRegularizeCOMs(s_t value);
  DynamicsFitProblemConfig& setRegularizeInertias(s_t value);
  DynamicsFitProblemConfig& setRegularizeBodyScales(s_t value);
  DynamicsFitProblemConfig& setRegularizePoses(s_t value);
  DynamicsFitProblemConfig& setRegularizeTrackingMarkerOffsets(s_t value);
  DynamicsFitProblemConfig& setRegularizeAnatomicalMarkerOffsets(s_t value);
  DynamicsFitProblemConfig& setRegularizeImpliedDensity(s_t value);

  DynamicsFitProblemConfig& setVelAccImplicit(bool implicit);

public:
  friend class DynamicsFitProblem;
  friend class DynamicsFitter;
  s_t mLinearNewtonWeight;
  s_t mResidualWeight;
  s_t mMarkerWeight;
  s_t mJointWeight;

  bool mConstrainResidualsZero;

  bool mLinearNewtonUseL1;
  bool mResidualUseL1;
  bool mMarkerUseL1;

  bool mIncludeMasses;
  bool mIncludeCOMs;
  bool mIncludeInertias;
  bool mIncludeBodyScales;
  bool mIncludePoses;
  bool mIncludeMarkerOffsets;

  s_t mRegularizeAcc;
  Eigen::VectorXs mRegularizeAccBodyWeights;
  bool mRegularizeAccUseL1;

  s_t mResidualTorqueMultiple;
  s_t mRegularizeMasses;
  s_t mRegularizeCOMs;
  s_t mRegularizeInertias;
  s_t mRegularizeBodyScales;
  s_t mRegularizePoses;
  s_t mRegularizeTrackingMarkerOffsets;
  s_t mRegularizeAnatomicalMarkerOffsets;
  s_t mRegularizeImpliedDensity;

  bool mVelAccImplicit;
};

/*
 * Reminder: IPOPT will want to free this object when it's done with
 * optimization. This is responsible for actually transcribing the problem into
 * a format IPOpt can work with.
 */
class DynamicsFitProblem : public Ipopt::TNLP
{
public:
  DynamicsFitProblem(
      std::shared_ptr<DynamicsInitialization> init,
      std::shared_ptr<dynamics::Skeleton> skeleton,
      std::vector<std::string> trackingMarkers,
      std::vector<dynamics::BodyNode*> footNodes,
      DynamicsFitProblemConfig config);

  // This returns the dimension of the decision variables (the length of the
  // flatten() vector), which depends on which variables we choose to include in
  // the optimization problem.
  int getProblemSize();

  // This writes the problem state into a flat vector
  Eigen::VectorXs flatten();

  // This writes the upper bounds into a flat vector
  Eigen::VectorXs flattenUpperBound();

  // This writes the upper bounds into a flat vector
  Eigen::VectorXs flattenLowerBound();

  // This reads the problem state out of a flat vector, and into the init object
  void unflatten(Eigen::VectorXs x);

  // This gets the value of the loss function, as a weighted sum of the
  // discrepancy between measured and expected GRF data and other regularization
  // terms.
  s_t computeLoss(Eigen::VectorXs x, bool logExplanation = false);

  // This gets the gradient of the loss function
  Eigen::VectorXs computeGradient(Eigen::VectorXs x);

  // This gets the gradient of the loss function
  Eigen::VectorXs finiteDifferenceGradient(
      Eigen::VectorXs x, bool useRidders = true);

  // This gets the number of constraints that the problem requires
  int getConstraintSize();

  // This gets the value of the constraints vector. These constraints are only
  // active when we're including positions in the decision variables, and they
  // just enforce that finite differencing is valid to relate velocity,
  // acceleration, and position.
  Eigen::VectorXs computeConstraints(Eigen::VectorXs x);

  // This gets the sparse version of the constraints jacobian, returning objects
  // with (row,col,value).
  std::vector<std::tuple<int, int, s_t>> computeSparseConstraintsJacobian();

  // This gets the jacobian of the constraints vector with respect to x. This is
  // constraint wrt x, so doesn't take x as an input
  Eigen::MatrixXs computeConstraintsJacobian();

  // This gets the jacobian of the constraints vector with respect to x
  Eigen::MatrixXs finiteDifferenceConstraintsJacobian();

  // Print out the errors in a gradient vector in human readable form
  bool debugErrors(Eigen::VectorXs fd, Eigen::VectorXs analytical, s_t tol);

  // This attempts to perfect the physical consistency of the data, and writes
  // them back to the problem
  void computePerfectGRFs();

  //------------------------- Ipopt::TNLP --------------------------------------
  /// \brief Method to return some info about the nlp
  bool get_nlp_info(
      Ipopt::Index& n,
      Ipopt::Index& m,
      Ipopt::Index& nnz_jac_g,
      Ipopt::Index& nnz_h_lag,
      Ipopt::TNLP::IndexStyleEnum& index_style) override;

  /// \brief Method to return the bounds for my problem
  bool get_bounds_info(
      Ipopt::Index n,
      Ipopt::Number* x_l,
      Ipopt::Number* x_u,
      Ipopt::Index m,
      Ipopt::Number* g_l,
      Ipopt::Number* g_u) override;

  /// \brief Method to return the starting point for the algorithm
  bool get_starting_point(
      Ipopt::Index n,
      bool init_x,
      Ipopt::Number* x,
      bool init_z,
      Ipopt::Number* z_L,
      Ipopt::Number* z_U,
      Ipopt::Index m,
      bool init_lambda,
      Ipopt::Number* lambda) override;

  /// \brief Method to return the objective value
  bool eval_f(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Number& _obj_value) override;

  /// \brief Method to return the gradient of the objective
  bool eval_grad_f(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Number* _grad_f) override;

  /// \brief Method to return the constraint residuals
  bool eval_g(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Index _m,
      Ipopt::Number* _g) override;

  /// \brief Method to return:
  ///        1) The structure of the jacobian (if "values" is nullptr)
  ///        2) The values of the jacobian (if "values" is not nullptr)
  bool eval_jac_g(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Index _m,
      Ipopt::Index _nele_jac,
      Ipopt::Index* _iRow,
      Ipopt::Index* _jCol,
      Ipopt::Number* _values) override;

  /// \brief Method to return:
  ///        1) The structure of the hessian of the lagrangian (if "values" is
  ///           nullptr)
  ///        2) The values of the hessian of the lagrangian (if "values" is not
  ///           nullptr)
  bool eval_h(
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      bool _new_x,
      Ipopt::Number _obj_factor,
      Ipopt::Index _m,
      const Ipopt::Number* _lambda,
      bool _new_lambda,
      Ipopt::Index _nele_hess,
      Ipopt::Index* _iRow,
      Ipopt::Index* _jCol,
      Ipopt::Number* _values) override;

  /// \brief This method is called when the algorithm is complete so the TNLP
  ///        can store/write the solution
  void finalize_solution(
      Ipopt::SolverReturn _status,
      Ipopt::Index _n,
      const Ipopt::Number* _x,
      const Ipopt::Number* _z_L,
      const Ipopt::Number* _z_U,
      Ipopt::Index _m,
      const Ipopt::Number* _g,
      const Ipopt::Number* _lambda,
      Ipopt::Number _obj_value,
      const Ipopt::IpoptData* _ip_data,
      Ipopt::IpoptCalculatedQuantities* _ip_cq) override;

  bool intermediate_callback(
      Ipopt::AlgorithmMode mode,
      Ipopt::Index iter,
      Ipopt::Number obj_value,
      Ipopt::Number inf_pr,
      Ipopt::Number inf_du,
      Ipopt::Number mu,
      Ipopt::Number d_norm,
      Ipopt::Number regularization_size,
      Ipopt::Number alpha_du,
      Ipopt::Number alpha_pr,
      Ipopt::Index ls_trials,
      const Ipopt::IpoptData* ip_data,
      Ipopt::IpoptCalculatedQuantities* ip_cq) override;

public:
  std::shared_ptr<DynamicsInitialization> mInit;
  std::shared_ptr<dynamics::Skeleton> mSkeleton;
  DynamicsFitProblemConfig mConfig;

  std::vector<Eigen::MatrixXs> mPoses;
  std::vector<Eigen::MatrixXs> mVels;
  std::vector<Eigen::MatrixXs> mAccs;

  std::vector<std::string> mMarkerNames;
  std::vector<bool> mMarkerIsTracking;
  std::vector<std::pair<dynamics::BodyNode*, Eigen::Vector3s>> mMarkers;

  std::vector<dynamics::BodyNode*> mFootNodes;
  std::vector<int> mForceBodyIndices;
  std::shared_ptr<ResidualForceHelper> mResidualHelper;
  std::shared_ptr<SpatialNewtonHelper> mSpatialNewtonHelper;

  int mBestObjectiveValueIteration;
  s_t mBestObjectiveValue;
  Eigen::VectorXs mLastX;
  Eigen::VectorXs mBestObjectiveValueState;
};

class DynamicsFitter
{
public:
  DynamicsFitter(
      std::shared_ptr<dynamics::Skeleton> skeleton,
      std::vector<dynamics::BodyNode*> footNodes,
      std::vector<std::string> trackingMarkers);

  // This bundles together the objects we need in order to track a dynamics
  // problem around through multiple steps of optimization
  static std::shared_ptr<DynamicsInitialization> createInitialization(
      std::shared_ptr<dynamics::Skeleton> skel,
      dynamics::MarkerMap markerMap,
      std::vector<std::string> trackingMarkers,
      std::vector<dynamics::BodyNode*> grfNodes,
      std::vector<std::vector<ForcePlate>> forcePlateTrials,
      std::vector<Eigen::MatrixXs> poseTrials,
      std::vector<int> framesPerSecond,
      std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
          markerObservationTrials);

  // This creates an optimization problem from a kinematics initialization
  static std::shared_ptr<DynamicsInitialization> createInitialization(
      std::shared_ptr<dynamics::Skeleton> skel,
      std::vector<MarkerInitialization> kinematicInit,
      std::vector<std::string> trackingMarkers,
      std::vector<dynamics::BodyNode*> grfNodes,
      std::vector<std::vector<ForcePlate>> forcePlateTrials,
      std::vector<int> framesPerSecond,
      std::vector<std::vector<std::map<std::string, Eigen::Vector3s>>>
          markerObservationTrials);

  // This retargets a dynamics initialization to another skeleton
  static std::shared_ptr<DynamicsInitialization> retargetInitialization(
      std::shared_ptr<dynamics::Skeleton> skel,
      std::shared_ptr<dynamics::Skeleton> simplifiedSkel,
      std::shared_ptr<DynamicsInitialization> init);

  // This computes and returns the positions of the center of mass at each
  // frame
  std::vector<Eigen::Vector3s> comPositions(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This computes and returns the positions of the center of mass at each
  // frame that would center the remaining angular residuals
  std::vector<Eigen::Vector3s> comPositionsToCenterResiduals(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This computes and returns the acceleration of the center of mass at each
  // frame
  std::vector<Eigen::Vector3s> comAccelerations(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // This computes and returns a list of the net forces on the center of mass,
  // given the motion and link masses
  std::vector<Eigen::Vector3s> impliedCOMForces(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      Eigen::Vector3s gravity = Eigen::Vector3s::Zero());

  // This returns a list of the total GRF force on the body at each timestep
  std::vector<Eigen::Vector3s> measuredGRFForces(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // 0. Estimate when each foot is in contact with the ground, which we can use
  // to infer when we're missing GRF data on certain timesteps, so we don't let
  // it mess with our optimization.
  void estimateFootGroundContacts(std::shared_ptr<DynamicsInitialization> init);

  // 0. Smooth the accelerations.
  void smoothAccelerations(std::shared_ptr<DynamicsInitialization> init);

  // 0. Estimate which timesteps probably have unmeasured external forces
  // present. By passing a number smaller than 1.0 to scaleThresholds, we can
  // increase the rate at which we throw out potentially bad data.
  void estimateUnmeasuredExternalForces(
      std::shared_ptr<DynamicsInitialization> init, s_t scaleThresholds = 1.0);

  // 0. Estimate which timesteps probably have unmeasured external torques
  // present. By passing a number smaller than 1.0 to scaleThresholds, we can
  // increase the rate at which we throw out potentially bad data.
  void estimateUnmeasuredExternalTorques(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      s_t scaleThresholds = 1.0);

  // This is pretty much just here for testing. It goes through and moves the
  // COM at every timestep to the spot it would need to be in order to minimize
  // angular residuals.
  void moveComsToMinimizeAngularResiduals(
      std::shared_ptr<DynamicsInitialization> init);

  // 1. Adjust the total mass of the body, and change the initial positions and
  // velocities of the body to achieve a least-squares closest COM trajectory to
  // the current kinematic fit.
  void zeroLinearResidualsOnCOMTrajectory(
      std::shared_ptr<DynamicsInitialization> init);

  // 1. Change the initial positions and velocities of the body to achieve a
  // least-squares closest COM trajectory to the current kinematic fit, taking
  // into account approximate angular positions.
  void zeroLinearResidualsAndOptimizeAngular(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      Eigen::MatrixXs targetPoses,
      s_t weightLinear = 1.0,
      s_t weightAngular = 1.0,
      s_t regularizeResiduals = 0.5);

  // 1.1. Attempt to shift the COM trajectory around to try to get the
  // residual-free trajectory. This can fail, when we've got unmeasured external
  // forces, too much smoothing on force plates, or severe model imperfections
  // (basically, if you just can't fit the data), so it returns a boolean false
  // on failure, and resets everything how it left it.
  bool optimizeSpatialResidualsOnCOMTrajectory(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      s_t satisfactoryThreshold = 1e-10);

  // 1.2. Now that we've got zero residuals, after calling
  // optimizeSpatialResidualsOnCOMTrajectory(), we can estimate the
  // miscalibration on the force plates, if there's consistent error on the
  // marker matches.
  void recalibrateForcePlates(
      std::shared_ptr<DynamicsInitialization> init,
      int trial,
      s_t maxMovement = 0.03);

  // This utility recomputes the GRF world wrenches, in case we changed the data
  void recomputeGRFs(std::shared_ptr<DynamicsInitialization> init, int trial);

  // 1. Shift the COM trajectory by a 3vec offset to minimize the amount of
  // remaining residual
  void centerAngularResiduals(std::shared_ptr<DynamicsInitialization> init);

  // 1. Do SGD to try to fit the root trajectory to minimize residuals, leaving
  // everything else fixed
  void optimizeRootTrajectory(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 1. Just use forward dynamics to get zero residuals.
  void zeroSpatialResidualsUsingForwardSim(
      std::shared_ptr<DynamicsInitialization> init, int resetEveryNSteps = -1);

  bool verifyLinearForceConsistency(
      std::shared_ptr<DynamicsInitialization> init);

  // 1. Scale the total mass of the body (keeping the ratios of body links
  // constant) to get it as close as possible to GRF gravity forces.
  void scaleLinkMassesFromGravity(std::shared_ptr<DynamicsInitialization> init);

  // 2. Estimate just link masses, while holding the positions, COMs, and
  // inertias constant
  void estimateLinkMassesFromAcceleration(
      std::shared_ptr<DynamicsInitialization> init,
      s_t regularizationWeight = 50.0);

  // 3. Run larger optimization problems to minimize a weighted combination of
  // residuals and marker RMSE, tweaking a controllable set of variables. This
  // includes the velocity and acceleration as explicit decision variables,
  // constrained by linear constraint equations. That means it needs to be
  // solved with IPOPT, using the interior point method.
  //
  // WARNING: DOES NOT PERFORM WELL WITH WARM STARTS! Becaus it uses the
  // interior point method, this doesn't warm start well. See
  // runImplicitVelAccOptimization() instead.
  void runIPOPTOptimization(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 4. This runs the same optimization problem as
  // runExplicitVelAccOptimization(), but holds velocity and acc as implicit
  // functions of the position values, and removes any constraints. That means
  // we can optimize this using simple gradient descent with line search, and
  // can warm start.
  void runSGDOptimization(
      std::shared_ptr<DynamicsInitialization> init,
      DynamicsFitProblemConfig config);

  // 5. This attempts to perfect the physical consistency of the data
  void computePerfectGRFs(std::shared_ptr<DynamicsInitialization> init);

  // This plays the simulation forward in Nimble, using the existing GRFs and
  // torques, and checks that everything matches what we expect to see
  bool checkPhysicalConsistency(
      std::shared_ptr<DynamicsInitialization> init,
      s_t maxAcceptableErrors = 1e-3,
      int maxTimestepsToTest = 50);

  // This writes a unified CSV with a ton of different columns in it, describing
  // the selected trial
  void writeCSVData(
      std::string path,
      std::shared_ptr<DynamicsInitialization> init,
      int trial);

  // This computes the inverse dynamics control forces for a trial, and returns
  // it.
  Eigen::MatrixXs computeInverseDynamics(
      std::shared_ptr<DynamicsInitialization> init, int trial);

  // Get the average RMSE, in meters, of the markers
  s_t computeAverageMarkerRMSE(std::shared_ptr<DynamicsInitialization> init);

  // Get the average residual force (in newtons) and torque (in newton-meters)
  std::pair<s_t, s_t> computeAverageResidualForce(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average real measured force (in newtons) and torque (in
  // newton-meters)
  std::pair<s_t, s_t> computeAverageRealForce(
      std::shared_ptr<DynamicsInitialization> init);

  // Get the average change in the center of pressure point (in meters) after
  // "perfecting" the GRF data
  s_t computeAverageCOPChange(std::shared_ptr<DynamicsInitialization> init);

  // Get the average change in the force vector (in Newtons) after "perfecting"
  // the GRF data
  s_t computeAverageForceMagnitudeChange(
      std::shared_ptr<DynamicsInitialization> init);

  // This debugs the current state, along with visualizations of errors where
  // the dynamics do not match the force plate data
  void saveDynamicsToGUI(
      const std::string& path,
      std::shared_ptr<DynamicsInitialization> init,
      int trialIndex,
      int framesPerSecond);

  void setTolerance(double tol);
  void setIterationLimit(int limit);
  void setLBFGSHistoryLength(int len);
  void setCheckDerivatives(bool check);
  void setPrintFrequency(int freq);
  void setSilenceOutput(bool silent);
  void setDisableLinesearch(bool disable);

protected:
  std::shared_ptr<dynamics::Skeleton> mSkeleton;
  std::vector<dynamics::BodyNode*> mFootNodes;
  std::vector<std::string> mTrackingMarkers;
  // These are IPOPT settings
  double mTolerance;
  int mIterationLimit;
  int mLBFGSHistoryLength;
  bool mCheckDerivatives;
  int mPrintFrequency;
  bool mSilenceOutput;
  bool mDisableLinesearch;
};

}; // namespace biomechanics
}; // namespace dart

#endif